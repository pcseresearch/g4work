//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
/*
 * The class KAOSAnalyse contains code to analyse and store the data in the steps
 * generated by the simulation.
 */


#ifndef ECalAnalysis_h
#define ECalAnalysis_h 1

#include <string>
#include <iostream>
#include <sstream>


#include "SBSVariables.hh"

#include "ECalStruct.hh"

// These are the Geant4 classes we work with
class G4VPhysicalVolume;
class G4Event;
class G4Run;
class G4Track;
class G4Step;

#include "G4ClassificationOfNewTrack.hh"
#include "G4TrackStatus.hh"

#include <time.h>

// We are using ROOT histogramms to store some data. And trees to store event data in files.

#define G4ANALYSIS_USE_ROOT 1

// Including the ROOT classes (look to include the path in the system)
#include "TROOT.h"
#include "TSystem.h"
#include "TFile.h"
#include "TTree.h"
#include "TParameter.h"
#include "TRandom2.h"



class ECalAnalysis {
  
public:
    ECalAnalysis();
    ~ECalAnalysis();
   
public:
  // Here we clear some counters at the begin of a run.  
  void BeginOfRunAction(const G4Run*);

  // Here we do the final analysis after a run.  
  void EndOfRunAction(const G4Run*);

  
  // G4UserEventAction
  void BeginOfEventAction(const G4Event*);
  // Here we clear some counters at the begin of an event.
  void EndOfEventAction(const G4Event*);
  // Here we analyse the total event.
  
  void TrackStartAction();
  void TrackStopAction();

  // G4UserStackingAction
//  void ClassifyNewTrack(const G4Track*, G4ClassificationOfNewTrack*);
//  void NewStage();
//  void PrepareNewEvent();
  
  // G4UserSteppingAction
  // We have different SteppingActions for different modes of operation.
    void StepAceptance(const G4Step *aStep);
  
    void dosave(); // Save the ROOT file

// Counter method
    void Counter();

//    void InitilizationOfEventAction();
// MY MODIFICATIONS

  G4int NumberOfEvents(const G4Run*);

  //  G4int GetNumberOfEvents();


    // GeneratorDaten *GetGDatenStruct() {return &gdaten;} ;  
    // G4UserRunAction
//  void BeginOfRunAction(const G4Run*);

 G4int TotalNnbEvent;//How many events have been set (public variable)   
  
private:
    void fillPerEvent(G4double, G4double, G4double, G4double);        
    
    G4double *psumEAbs;       

    G4double sumEAbs, sum2EAbs;
    G4double sumEGap, sum2EGap;

    G4double sumLAbs, sum2LAbs;
    G4double sumLGap, sum2LGap;    
  
    G4double  EnergyAbs;
    G4double  EnergyGap;

    G4double EnergyTemp;

//variables to be stored
    G4double  EnergyAbsMod[NoMaxModules];
    G4double  EnergyGapMod[NoMaxModules];
    G4double  EnergyGapModLay[NoMaxModules][20];

//I Keep this variables because I'm not sure, its probable to use later 
// and its well implemented
    G4double  TrackLAbs;
    G4double  TrackLGap;
  
    G4int     testvalue;       

    G4int     printModulo;

    G4double edep;
    G4double stepl;
    
    G4ThreeVector Position;
 
    
    G4int nbEventInRun; //How many events have been set
    G4int NbOfEventsC;//Number of present event (Counter)
    G4int NbOfEvents;//Number of present event (RunAction). It is neccesary at the end of the run, calculate
                     // it in other part is not clear

    G4double RestEventFactor;//Is a factor based in events ocurred to estimate time to finish
    G4double time_elapsed;
    time_t resttime;
    time_t start, end;
    G4double length;
  
    G4int Even25;//25% of events done (module), aproximate value since is not simple to implement
                 // exact value

    void StepStart(const G4Step *aStep); 
    
    // Called by KAOSSteppingAction.
    G4bool Entry(G4String Volumen); // True if particle enters volume with name "Volumen"
    G4bool Exit(G4String Volumen); // True if particle leaves volume with name "Volumen"
    void CheckSM(G4String Volumename, G4int ID, const G4Step *aStep);
    void CheckAkzeptiert(); // Check if particle enters the front of KAOS dipolefield

    TFile *CreateSaveFile(G4String Name); // Creating a ROOT file for output with the filename "Name"

 
    G4String ActualVolume, NextVolume; // At start of step, the names of the actual volume
    //an the next volume are stored here
    G4Track *actualTrack; // pointer to the actual track
    
    TFile *rootfile; // the ROOT file for output

    G4Run *Run; // pointer to the current Run

    G4String      FileNameSuffix;	


/*
  KAOSRunManager *RunManager; // pointer to the used RunManager
  

  time_t LastDoItTime; // used in OnceAWhileDoIt method
  time_t LastLongDoItTime; // used in OnceAWhileDoIt method
  time_t StartTime; // used in OnceAWhileDoIt method
  G4int PrintCounter;
  G4int TotalEvents; // total number of events simulated so far

  G4double Gewicht; // a weight for the current event
  G4double GesamtGewicht; // sum of all weights simulated so far.
  G4bool akzeptiert; // true if particle track crosses the entrance window of KAOS
  G4double verbose; // level of output.

  Impulsdaten idaten; // struct for the baum_i ROOT tree
  AkzeptanzdatenSciFi adaten; // struct for the baum_a ROOT tree
  UntergrunddatenSciFi udaten; // struct for the baum_u ROOT tree
  SciFiDaten sdaten; // struct for the baum_s ROOT tree
  GeneratorDaten gdaten; // struct for the baum_g ROOT tree
  G4double EinZ; 
  G4double KinZ;
  G4double FEE_Y;
  G4double FEE_P;
  
  G4double FEImpuls;
  G4double FEEImpuls;
  
  G4int Eventnummer; // number of current event
 
  TRandom2 *RRandom; // random number generator

 
 

  G4double EnergydepositionTH[2304*4];
  G4double EnergydepositionX[(2304*4)*2];

  G4double EnergydepositionPS;

  //  G4double *EnergiedepositionX;
  //  G4double *EnergiedepositionTH;
//  G4double DurchflogenE[FEE_MAXPADDLEANZAHL*8];
  G4double DurchflogenE;
  G4double FEEY_y;
  G4double FEEY_z;

  G4int lastevent;

  // NoP=Number of particles
  // is necesary since the analysis is implemented for 2 particles 
  // at the begining but doesn't wor for scan analysis
  G4int NoP;

  G4ThreeVector lastPosition;

  ostringstream DrawTrackKommando;
*/

    TTree *eventtree;
    TTree *hittree;
    TTree *settree;
    TTree *deptree;
    double depholder[NoMaxModules][20];    
    
    UTEvent event; 
    UThit hit; 
    UTSet set; 

  // string to store a commando to draw a track in LISP for AutoCAD
};

#endif

